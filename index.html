<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF File Separator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@300;400;500;600;700&family=DM+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --ink: #0f0f12;
            --ink-soft: #3a3a4a;
            --ink-muted: #7a7a8e;
            --surface: #ffffff;
            --surface-2: #f4f4f8;
            --surface-3: #eaeaf0;
            --accent: #4f46e5;
            --accent-light: #ede9fe;
            --accent-glow: rgba(79,70,229,0.15);
            --success: #059669;
            --success-light: #d1fae5;
            --danger: #dc2626;
            --danger-light: #fee2e2;
            --warn: #d97706;
            --warn-light: #fef3c7;
            --radius: 12px;
            --radius-sm: 8px;
            --shadow: 0 1px 3px rgba(0,0,0,0.08), 0 4px 16px rgba(0,0,0,0.06);
            --shadow-lg: 0 8px 32px rgba(0,0,0,0.14), 0 2px 8px rgba(0,0,0,0.06);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'DM Sans', sans-serif;
            background: #f0f0f6;
            background-image:
                radial-gradient(circle at 20% 20%, rgba(79,70,229,0.06) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(124,58,237,0.04) 0%, transparent 50%);
            min-height: 100vh;
            color: var(--ink);
        }

        .topbar {
            background: var(--surface);
            border-bottom: 1px solid var(--surface-3);
            padding: 0 40px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        .topbar-brand { display: flex; align-items: center; gap: 10px; font-weight: 700; font-size: 1.05em; }
        .topbar-brand .dot { width: 8px; height: 8px; background: var(--accent); border-radius: 50%; }
        .topbar-status { font-size: 0.78em; color: var(--ink-muted); font-family: 'DM Mono', monospace; display: flex; align-items: center; gap: 8px; }
        .status-dot { width: 6px; height: 6px; border-radius: 50%; background: var(--success); animation: pulse-dot 2s infinite; }
        @keyframes pulse-dot { 0%,100%{opacity:1} 50%{opacity:.4} }

        .main { max-width: 1320px; margin: 0 auto; padding: 40px 32px 130px; }

        #uploadSection { display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: calc(100vh - 140px); }
        .upload-hero { text-align: center; margin-bottom: 40px; }
        .upload-hero h1 { font-size: 2.8em; font-weight: 700; line-height: 1.1; margin-bottom: 12px; }
        .upload-hero h1 em { font-style: normal; color: var(--accent); }
        .upload-hero p { color: var(--ink-muted); font-size: 1.05em; }

        .upload-zone {
            width: 100%; max-width: 600px;
            border: 2px dashed var(--surface-3);
            border-radius: 20px; background: var(--surface);
            padding: 70px 50px; text-align: center; cursor: pointer;
            transition: all 0.25s ease; box-shadow: var(--shadow);
        }
        .upload-zone:hover, .upload-zone.dragover {
            border-color: var(--accent); background: #fafafe;
            box-shadow: 0 0 0 6px var(--accent-glow), var(--shadow-lg);
            transform: translateY(-2px);
        }
        .upload-zone.dragover { background: var(--accent-light); }
        .upload-icon-wrap { width: 72px; height: 72px; background: var(--accent-light); border-radius: 18px; display: flex; align-items: center; justify-content: center; margin: 0 auto 24px; font-size: 2em; transition: transform 0.2s; }
        .upload-zone:hover .upload-icon-wrap { transform: scale(1.1) rotate(-4deg); }
        .upload-zone h3 { font-size: 1.15em; font-weight: 600; margin-bottom: 6px; }
        .upload-zone p { color: var(--ink-muted); font-size: 0.9em; }
        .upload-zone .size-note { display: inline-block; margin-top: 16px; font-size: 0.78em; font-family: 'DM Mono', monospace; color: var(--ink-muted); background: var(--surface-2); padding: 4px 12px; border-radius: 20px; }
        .privacy-note { margin-top: 20px; font-size: 0.82em; color: var(--ink-muted); display: flex; align-items: center; gap: 6px; }
        #fileInput { display: none; }

        #pagesSection { display: none; }
        #pagesSection.active { display: block; }

        .pages-header { display: flex; align-items: flex-start; justify-content: space-between; margin-bottom: 20px; gap: 20px; flex-wrap: wrap; }
        .pages-title h2 { font-size: 1.7em; font-weight: 700; }
        .pages-title p { color: var(--ink-muted); font-size: 0.9em; margin-top: 4px; }

        .progress-label { font-size: 0.82em; color: var(--ink-muted); font-family: 'DM Mono', monospace; margin-bottom: 8px; display: flex; justify-content: space-between; }
        .progress-bar-wrap { background: var(--surface-3); border-radius: 20px; height: 6px; margin-bottom: 20px; overflow: hidden; }
        .progress-bar-fill { height: 100%; background: linear-gradient(90deg, var(--accent), #7c3aed); border-radius: 20px; transition: width 0.4s ease; width: 0%; }

        .quick-assign-panel {
            background: var(--surface);
            border: 1px solid var(--surface-3);
            border-radius: var(--radius);
            margin-bottom: 16px;
            box-shadow: var(--shadow);
            overflow: hidden;
        }
        .quick-assign-header {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 16px 20px 12px;
            border-bottom: 1px solid var(--surface-3);
        }
        .quick-assign-icon { font-size: 1.2em; margin-top: 1px; flex-shrink: 0; }
        .quick-assign-title { font-weight: 700; font-size: 0.95em; color: var(--ink); margin-bottom: 3px; }
        .quick-assign-sub { font-size: 0.8em; color: var(--ink-muted); line-height: 1.4; }
        .quick-assign-body { display: flex; align-items: center; gap: 14px; padding: 14px 20px; flex-wrap: wrap; }
        .quick-assign-step { display: flex; align-items: center; gap: 10px; }
        .step-badge { width: 22px; height: 22px; border-radius: 50%; background: var(--accent); color: white; font-size: 0.72em; font-weight: 700; display: flex; align-items: center; justify-content: center; flex-shrink: 0; }
        .step-text { font-size: 0.84em; font-weight: 600; color: var(--ink-soft); white-space: nowrap; }
        .quick-assign-arrow { font-size: 1.1em; color: var(--ink-muted); flex-shrink: 0; }
        .quick-assign-divider { width: 1px; height: 28px; background: var(--surface-3); flex-shrink: 0; }
        .bulk-select { padding: 8px 14px; border: 1.5px solid var(--surface-3); border-radius: var(--radius-sm); font-family: 'DM Sans', sans-serif; font-size: 0.88em; color: var(--ink); background: var(--surface-2); cursor: pointer; transition: border-color 0.2s; }
        .bulk-select:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 3px var(--accent-glow); }
        .tbtn { font-family: 'DM Sans', sans-serif; font-size: 0.83em; font-weight: 600; padding: 8px 16px; border-radius: var(--radius-sm); border: 1.5px solid transparent; cursor: pointer; transition: all 0.18s; white-space: nowrap; }
        .tbtn-primary { background: var(--accent); color: white; border-color: var(--accent); }
        .tbtn-primary:hover { background: #4338ca; transform: translateY(-1px); }
        .tbtn-ghost { background: transparent; color: var(--ink-muted); border-color: var(--surface-3); }
        .tbtn-ghost:hover { border-color: var(--danger); color: var(--danger); }

        .drag-hint { font-size: 0.8em; color: var(--ink-muted); background: var(--surface-2); border: 1px solid var(--surface-3); border-radius: var(--radius-sm); padding: 8px 14px; margin-bottom: 16px; display: flex; align-items: center; gap: 8px; }

        .uncategorized-banner { background: var(--warn-light); border: 1px solid #fcd34d; color: var(--warn); border-radius: var(--radius-sm); padding: 10px 14px; font-size: 0.86em; font-weight: 500; display: none; align-items: center; gap: 8px; margin-bottom: 18px; }
        .uncategorized-banner.visible { display: flex; }

        .pages-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(230px, 1fr)); gap: 18px; margin-bottom: 32px; }

        .page-card {
            background: var(--surface); border: 2px solid var(--surface-3);
            border-radius: var(--radius); overflow: hidden;
            transition: border-color 0.2s, box-shadow 0.2s, transform 0.15s, opacity 0.15s;
            box-shadow: var(--shadow); position: relative; cursor: grab; user-select: none;
        }
        .page-card:active { cursor: grabbing; }
        .page-card:hover { box-shadow: var(--shadow-lg); border-color: #c7c7e0; }
        .page-card.categorized { border-color: var(--accent); box-shadow: 0 0 0 3px var(--accent-glow), var(--shadow); }
        .page-card.dragging { opacity: 0.3; transform: scale(0.96); cursor: grabbing; }
        .page-card.drag-over { border-color: var(--accent); box-shadow: 0 0 0 4px var(--accent-glow), var(--shadow-lg); transform: scale(1.03); }

        .card-header { padding: 10px 12px 6px; display: flex; align-items: center; justify-content: space-between; gap: 6px; }
        .card-header-left { display: flex; align-items: center; gap: 6px; }
        .drag-handle { color: var(--ink-muted); font-size: 1em; cursor: grab; padding: 2px 4px; border-radius: 4px; transition: color 0.15s, background 0.15s; line-height: 1; }
        .drag-handle:hover { color: var(--accent); background: var(--accent-light); }
        .page-label { font-size: 0.74em; font-family: 'DM Mono', monospace; font-weight: 500; color: var(--ink-muted); background: var(--surface-2); padding: 2px 8px; border-radius: 20px; }
        .page-card.categorized .page-label { background: var(--accent-light); color: var(--accent); }
        .check-badge { width: 20px; height: 20px; border-radius: 50%; background: var(--accent); display: none; align-items: center; justify-content: center; color: white; font-size: 0.6em; }
        .page-card.categorized .check-badge { display: flex; animation: pop-in 0.3s cubic-bezier(0.34,1.56,0.64,1); }
        @keyframes pop-in { 0%{transform:scale(0);opacity:0} 100%{transform:scale(1);opacity:1} }

        .page-preview-wrap { margin: 0 10px; background: var(--surface-2); border-radius: 8px; overflow: hidden; min-height: 150px; display: flex; align-items: center; justify-content: center; }
        .page-preview { width: 100%; display: block; border-radius: 6px; transition: transform 0.35s cubic-bezier(0.34,1.2,0.64,1); transform-origin: center center; }
        .page-loading-placeholder { display: flex; flex-direction: column; align-items: center; gap: 10px; color: var(--ink-muted); font-size: 0.78em; padding: 28px 0; }
        .mini-spinner { width: 26px; height: 26px; border: 3px solid var(--surface-3); border-top-color: var(--accent); border-radius: 50%; animation: spin 0.7s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }

        .rotation-controls { display: flex; align-items: center; justify-content: center; gap: 4px; padding: 8px 10px 2px; flex-wrap: wrap; }
        .rot-btn { width: 30px; height: 30px; border: 1.5px solid var(--surface-3); background: var(--surface-2); border-radius: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 1em; transition: all 0.15s; color: var(--ink-soft); flex-shrink: 0; }
        .rot-btn:hover { border-color: var(--accent); background: var(--accent-light); color: var(--accent); transform: scale(1.12); }
        .rot-btn:active { transform: scale(0.95); }
        .rot-label { font-size: 0.68em; font-family: 'DM Mono', monospace; color: var(--ink-muted); min-width: 28px; text-align: center; }

        .card-footer { padding: 6px 10px 12px; }
        .category-select { width: 100%; padding: 9px 28px 9px 12px; border: 1.5px solid var(--surface-3); border-radius: var(--radius-sm); font-family: 'DM Sans', sans-serif; font-size: 0.86em; color: var(--ink); background: var(--surface-2); cursor: pointer; transition: all 0.2s; appearance: none; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%237a7a8e' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E"); background-repeat: no-repeat; background-position: right 10px center; }
        .category-select:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 3px var(--accent-glow); background-color: var(--surface); }
        .page-card.categorized .category-select { border-color: var(--accent); color: var(--accent); background-color: var(--accent-light); }

        .action-bar { background: var(--surface); border: 1px solid var(--surface-3); border-radius: var(--radius); padding: 16px 24px; display: flex; align-items: center; justify-content: space-between; gap: 16px; flex-wrap: wrap; box-shadow: var(--shadow-lg); position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); width: calc(100% - 64px); max-width: 1320px; z-index: 90; }
        .action-bar-info { font-size: 0.88em; color: var(--ink-muted); }
        .action-bar-buttons { display: flex; gap: 10px; }
        .btn { font-family: 'DM Sans', sans-serif; font-weight: 600; font-size: 0.9em; padding: 11px 22px; border-radius: var(--radius-sm); border: none; cursor: pointer; transition: all 0.2s ease; display: inline-flex; align-items: center; gap: 7px; }
        .btn-primary { background: var(--accent); color: white; }
        .btn-primary:hover:not(:disabled) { background: #4338ca; transform: translateY(-1px); box-shadow: 0 4px 16px rgba(79,70,229,0.35); }
        .btn-primary:disabled { opacity: 0.4; cursor: not-allowed; }
        .btn-secondary { background: var(--surface-2); color: var(--ink-soft); border: 1.5px solid var(--surface-3); }
        .btn-secondary:hover { background: var(--surface-3); color: var(--ink); }

        .loading-overlay { display: none; position: fixed; inset: 0; background: rgba(255,255,255,0.88); backdrop-filter: blur(6px); z-index: 200; flex-direction: column; align-items: center; justify-content: center; gap: 18px; }
        .loading-overlay.active { display: flex; }
        .loader-ring { width: 52px; height: 52px; border: 4px solid var(--surface-3); border-top-color: var(--accent); border-radius: 50%; animation: spin 0.8s linear infinite; }
        .loader-text { font-weight: 600; color: var(--ink-soft); font-size: 1em; }
        .loader-sub { font-size: 0.8em; color: var(--ink-muted); font-family: 'DM Mono', monospace; }

        .toast-container { position: fixed; bottom: 90px; right: 28px; z-index: 300; display: flex; flex-direction: column; gap: 10px; }
        .toast { background: var(--surface); border: 1px solid var(--surface-3); border-radius: var(--radius); padding: 12px 16px; font-size: 0.86em; font-weight: 500; box-shadow: var(--shadow-lg); display: flex; align-items: center; gap: 10px; max-width: 340px; animation: slide-in 0.3s cubic-bezier(0.34,1.56,0.64,1); transition: opacity 0.25s, transform 0.25s; }
        .toast.hide { opacity: 0; transform: translateX(20px); }
        @keyframes slide-in { from{opacity:0;transform:translateX(20px)} to{opacity:1;transform:translateX(0)} }
        .toast-icon { width: 26px; height: 26px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.8em; flex-shrink: 0; }
        .toast.success .toast-icon { background: var(--success-light); color: var(--success); }
        .toast.success { border-color: #a7f3d0; }
        .toast.error .toast-icon { background: var(--danger-light); color: var(--danger); }
        .toast.error { border-color: #fca5a5; }
        .toast.warn .toast-icon { background: var(--warn-light); color: var(--warn); }
        .toast.warn { border-color: #fcd34d; }

        /* ‚îÄ‚îÄ Annotation overlay & toolbar ‚îÄ‚îÄ */
        .page-preview-container { position: relative; width: 100%; line-height: 0; }

        .annotation-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            cursor: crosshair; z-index: 2; touch-action: none;
        }

        .annot-toolbar {
            padding: 5px 6px; background: var(--surface-2);
            border-top: 1px solid var(--surface-3);
            display: flex; flex-wrap: wrap; gap: 3px; align-items: center;
        }

        .annot-tool {
            width: 24px; height: 24px; border: 1.5px solid var(--surface-3);
            background: var(--surface); border-radius: 5px; cursor: pointer;
            font-size: 0.8em; display: flex; align-items: center; justify-content: center;
            padding: 0; transition: all 0.15s; flex-shrink: 0; line-height: 1;
            font-family: 'DM Sans', sans-serif; color: var(--ink-soft);
        }
        .annot-tool:hover { border-color: var(--accent); background: var(--accent-light); color: var(--accent); }
        .annot-tool.active { border-color: var(--accent); background: var(--accent); color: white; }

        .annot-color {
            width: 24px; height: 24px; border: 1.5px solid var(--surface-3);
            border-radius: 5px; padding: 1px; cursor: pointer; flex-shrink: 0;
            background: none;
        }

        .annot-brush { width: 58px; height: 4px; flex-shrink: 0; cursor: pointer; accent-color: var(--accent); }

        .annot-fontsize {
            width: 34px; border: 1.5px solid var(--surface-3); border-radius: 5px;
            font-size: 0.75em; padding: 2px 3px; flex-shrink: 0; text-align: center;
            font-family: 'DM Mono', monospace; color: var(--ink-soft); background: var(--surface);
        }
        .annot-fontsize:focus { outline: none; border-color: var(--accent); }

        .annot-sep { width: 1px; height: 18px; background: var(--surface-3); flex-shrink: 0; margin: 0 1px; }

        .annot-action {
            width: 24px; height: 24px; border: 1.5px solid var(--surface-3);
            background: var(--surface); border-radius: 5px; cursor: pointer;
            font-size: 0.8em; padding: 0; transition: all 0.15s; flex-shrink: 0;
            display: flex; align-items: center; justify-content: center; color: var(--ink-soft);
        }
        .annot-action:hover { border-color: var(--danger); color: var(--danger); background: var(--danger-light); }

        .annot-text-input {
            position: absolute; background: transparent; border: 1px dashed;
            outline: none; min-width: 60px; font-family: 'DM Sans', sans-serif;
            z-index: 10; padding: 1px 2px;
        }

        @media (max-width: 640px) {
            .main { padding: 20px 14px 140px; }
            .topbar { padding: 0 16px; }
            .action-bar { width: calc(100% - 28px); bottom: 12px; }
            .upload-zone { padding: 48px 20px; }
        }
    </style>
</head>
<body>

<header class="topbar">
    <div class="topbar-brand">
        <div class="dot"></div>
        PDF Separator
    </div>
    <div class="topbar-status">
        <div class="status-dot"></div>
        Client-side only
    </div>
</header>

<div class="main">
    <div id="uploadSection">
        <div class="upload-hero">
            <h1>Split your PDF<br>into <em>separate</em> documents</h1>
            <p>Reorder, rotate, categorize ‚Äî then download a clean ZIP.</p>
        </div>
        <div class="upload-zone" id="uploadArea">
            <div class="upload-icon-wrap">üìÑ</div>
            <h3>Drop your PDF here</h3>
            <p>or click to browse files</p>
            <span class="size-note">Max 50 MB ¬∑ PDF only</span>
        </div>
        <p class="privacy-note">üîí All processing happens in your browser</p>
        <input type="file" id="fileInput" accept=".pdf">
    </div>

    <div id="pagesSection">
        <div class="pages-header">
            <div class="pages-title">
                <h2>Categorize your pages</h2>
                <p id="pagesSummaryText">Loading‚Ä¶</p>
            </div>
            <button class="btn btn-secondary" onclick="resetApp()">‚Üê New File</button>
        </div>

        <div class="progress-label">
            <span id="progressLabelText">0 of 0 pages assigned</span>
            <span id="progressLabelPct">0%</span>
        </div>
        <div class="progress-bar-wrap">
            <div class="progress-bar-fill" id="progressFill"></div>
        </div>

        <div class="quick-assign-panel">
            <div class="quick-assign-header">
                <span class="quick-assign-icon">‚ö°</span>
                <div>
                    <div class="quick-assign-title">Assign all pages at once</div>
                    <div class="quick-assign-sub">Useful when most pages belong to the same category.</div>
                </div>
            </div>
            <div class="quick-assign-body">
                <div class="quick-assign-step">
                    <span class="step-badge">1</span>
                    <span class="step-text">Pick a category</span>
                    <select class="bulk-select" id="bulkCategory">
                        <option value="">Choose‚Ä¶</option>
                    </select>
                </div>
                <div class="quick-assign-arrow">‚Üí</div>
                <div class="quick-assign-step">
                    <span class="step-badge">2</span>
                    <span class="step-text">Apply it</span>
                    <button class="tbtn tbtn-primary" onclick="applyBulkCategory()">Assign to all unset pages</button>
                </div>
                <div class="quick-assign-divider"></div>
                <button class="tbtn tbtn-ghost" onclick="clearAllCategories()">‚úï Clear all</button>
            </div>
        </div>

        <div class="drag-hint">
            ‚†ø <strong>Drag</strong> to reorder ¬∑ ‚Ü∫‚Üª rotate ¬∑ ‚Üî‚Üï flip
        </div>

        <div class="uncategorized-banner" id="uncategorizedBanner">
            ‚ö†Ô∏è <span id="uncategorizedText"></span>
        </div>

        <div class="pages-grid" id="pagesGrid"></div>
    </div>
</div>

<div class="action-bar" id="actionBar" style="display:none;">
    <div class="action-bar-info" id="actionBarInfo">Assign categories to pages, then download.</div>
    <div class="action-bar-buttons">
        <button class="btn btn-primary" id="downloadBtn" onclick="downloadSeparatedPDFs()" disabled>
            ‚¨á Download ZIP
        </button>
    </div>
</div>

<div class="loading-overlay" id="loadingOverlay">
    <div class="loader-ring"></div>
    <div class="loader-text" id="loaderText">Processing‚Ä¶</div>
    <div class="loader-sub" id="loaderSub"></div>
</div>

<div class="toast-container" id="toastContainer"></div>

<script>
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

let originalFileBlob = null;
let pdfDoc = null;
let totalPages = 0;
let pageOrder = [];
const pageCategories = {};
const pageRotations = {};
const pageFlips = {};
const thumbnailCache = {};

const CATEGORIES = [
    { value: 'police-report', label: 'Police Report' },
    { value: 'vehicle-reg', label: 'Vehicle Registration' },
    { value: 'driver-license', label: 'Driver License' },
    { value: 'civil-id', label: 'Civil ID' },
    { value: 'incident-report', label: 'Incident Report' },
    { value: 'garage-estimation', label: 'Garage Estimation' },
    { value: 'insurance-policy', label: 'Insurance Policy' },
    { value: 'other', label: 'Other' }
];

const bulkSelect = document.getElementById('bulkCategory');
CATEGORIES.forEach(c => {
    const o = document.createElement('option');
    o.value = c.value;
    o.textContent = c.label;
    bulkSelect.appendChild(o);
});

const uploadArea = document.getElementById('uploadArea');
const fileInput = document.getElementById('fileInput');

uploadArea.addEventListener('click', () => fileInput.click());
uploadArea.addEventListener('dragover', e => { e.preventDefault(); uploadArea.classList.add('dragover'); });
uploadArea.addEventListener('dragleave', () => uploadArea.classList.remove('dragover')); 
uploadArea.addEventListener('drop', e => {
    e.preventDefault();
    uploadArea.classList.remove('dragover');
    if (e.dataTransfer.files[0]) validateAndLoad(e.dataTransfer.files[0]);
});
fileInput.addEventListener('change', e => { if (e.target.files[0]) validateAndLoad(e.target.files[0]); });

function validateAndLoad(file) {
    if (file.type !== 'application/pdf') { showToast('Please upload a valid PDF file.', 'error'); return; }
    if (file.size > 50 * 1024 * 1024) { showToast('File exceeds 50 MB limit.', 'error'); return; }
    originalFileBlob = file;
    showLoading('Loading PDF‚Ä¶', file.name);
    file.arrayBuffer().then(buf => {
        pdfjsLib.getDocument({ data: new Uint8Array(buf) }).promise.then(doc => {
            pdfDoc = doc;
            totalPages = doc.numPages;
            pageOrder = Array.from({ length: totalPages }, (_, i) => i + 1);
            document.getElementById('uploadSection').style.display = 'none';
            document.getElementById('pagesSection').classList.add('active');
            document.getElementById('actionBar').style.display = 'flex';
            document.getElementById('pagesSummaryText').textContent = `${totalPages} page${totalPages !== 1 ? 's' : ''} ready to organize`;
            buildGrid();
            hideLoading();
            updateProgress();
        }).catch(() => { hideLoading(); showToast('Could not read PDF.', 'error'); });
    });
}

function buildGrid() {
    const grid = document.getElementById('pagesGrid');
    grid.innerHTML = '';
    pageOrder.forEach(p => grid.appendChild(makeCard(p)));
    renderThumbnailsBatched();
    initDragDrop();
}

function makeCard(origPage) {
    const card = document.createElement('div');
    card.className = 'page-card' + (pageCategories[origPage] ? ' categorized' : '');
    card.dataset.page = origPage;
    card.draggable = true;

    const opts = CATEGORIES.map(c => `<option value="${c.value}"${pageCategories[origPage] === c.value ? ' selected' : ''}>${c.label}</option>`).join('');

    card.innerHTML = `
        <div class="card-header">
            <div class="card-header-left">
                <span class="drag-handle">‚†ø</span>
                <span class="page-label">Page ${origPage}</span>
            </div>
            <div class="check-badge">‚úì</div>
        </div>
        <div class="page-preview-wrap" id="preview-wrap-${origPage}">
            <div class="page-loading-placeholder">
                <div class="mini-spinner"></div>
                <span>Rendering‚Ä¶</span>
            </div>
        </div>
        <div class="annot-toolbar" id="annot-toolbar-${origPage}">
            <button class="annot-tool active" data-tool="pen" title="Free Draw" aria-label="Free Draw">‚úè</button>
            <button class="annot-tool" data-tool="line" title="Straight Line" aria-label="Straight Line">‚ï±</button>
            <button class="annot-tool" data-tool="rect" title="Rectangle" aria-label="Rectangle">‚ñ≠</button>
            <button class="annot-tool" data-tool="circle" title="Circle" aria-label="Circle">‚óØ</button>
            <button class="annot-tool" data-tool="arrow" title="Arrow" aria-label="Arrow">‚Üó</button>
            <button class="annot-tool" data-tool="text" title="Text" aria-label="Text">T</button>
            <div class="annot-sep"></div>
            <input type="color" class="annot-color" value="#ff0000" title="Color" aria-label="Annotation color">
            <input type="range" class="annot-brush" min="1" max="20" value="3" title="Brush size" aria-label="Brush size">
            <input type="number" class="annot-fontsize" min="8" max="72" value="16" title="Font size (text tool)" aria-label="Font size">
            <div class="annot-sep"></div>
            <button class="annot-action" data-action="undo" title="Undo last stroke" aria-label="Undo last stroke">‚Ü©</button>
            <button class="annot-action" data-action="clear" title="Clear all annotations" aria-label="Clear all annotations">‚úï</button>
        </div>
        <div class="rotation-controls">
            <button class="rot-btn" onclick="event.stopPropagation();rotateImg(${origPage},-90)">‚Ü∫</button>
            <button class="rot-btn" onclick="event.stopPropagation();rotateImg(${origPage}, 90)">‚Üª</button>
            <button class="rot-btn" onclick="event.stopPropagation();flipImg(${origPage},'h')">‚Üî</button>
            <button class="rot-btn" onclick="event.stopPropagation();flipImg(${origPage},'v')">‚Üï</button>
            <span class="rot-label" id="rot-label-${origPage}">${pageRotations[origPage]||0}¬∞</span>
        </div>
        <div class="card-footer">
            <select class="category-select" data-page="${origPage}">
                <option value="">Select category‚Ä¶</option>
                ${opts}
            </select>
        </div>
    `;

    card.querySelector('select').addEventListener('change', e => setCategory(origPage, e.target.value));

    initAnnotToolbar(origPage, card);

    if (thumbnailCache[origPage]) {
        injectThumbnail(origPage, thumbnailCache[origPage]);
    }

    return card;
}

async function renderThumbnailsBatched() {
    const needed = pageOrder.filter(p => !thumbnailCache[p]);
    const BATCH = 4;
    for (let i = 0; i < needed.length; i += BATCH) {
        await Promise.all(needed.slice(i, i + BATCH).map(p => renderThumbnail(p)));
    }
}

async function renderThumbnail(pageNum) {
    if (thumbnailCache[pageNum]) { injectThumbnail(pageNum, thumbnailCache[pageNum]); return; }
    try {
        const page = await pdfDoc.getPage(pageNum);
        const viewport = page.getViewport({ scale: 0.6 });
        const canvas = document.createElement('canvas');
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        await page.render({ canvasContext: canvas.getContext('2d'), viewport }).promise;
        const dataURL = canvas.toDataURL('image/jpeg', 0.72);
        thumbnailCache[pageNum] = dataURL;
        injectThumbnail(pageNum, dataURL);
    } catch (_) {}
}

function injectThumbnail(pageNum, dataURL) {
    const wrap = document.getElementById(`preview-wrap-${pageNum}`);
    if (!wrap) return;

    const container = document.createElement('div');
    container.className = 'page-preview-container';

    const img = document.createElement('img');
    img.src = dataURL;
    img.className = 'page-preview';
    img.alt = `Page ${pageNum}`;
    img.id = `img-${pageNum}`;

    const canvas = document.createElement('canvas');
    canvas.className = 'annotation-canvas';
    canvas.id = `annot-canvas-${pageNum}`;

    container.appendChild(img);
    container.appendChild(canvas);
    wrap.innerHTML = '';
    wrap.appendChild(container);

    applyTransform(pageNum);

    const doInit = () => initAnnotCanvas(pageNum, canvas, img);
    if (img.complete && img.naturalWidth) doInit();
    else img.addEventListener('load', doInit);
}

function rotateImg(pageNum, delta) {
    pageRotations[pageNum] = ((pageRotations[pageNum] || 0) + delta + 360) % 360;
    applyTransform(pageNum);
    const lbl = document.getElementById(`rot-label-${pageNum}`);
    if (lbl) lbl.textContent = pageRotations[pageNum] + '¬∞';
}

function flipImg(pageNum, axis) {
    if (!pageFlips[pageNum]) pageFlips[pageNum] = { h: false, v: false };
    pageFlips[pageNum][axis] = !pageFlips[pageNum][axis];
    applyTransform(pageNum);
}

function applyTransform(pageNum) {
    const img = document.getElementById(`img-${pageNum}`);
    if (!img) return;
    const rot = pageRotations[pageNum] || 0;
    const flp = pageFlips[pageNum] || { h: false, v: false };
    let t = '';
    if (rot) t += `rotate(${rot}deg) `;
    if (flp.h) t += 'scaleX(-1) ';
    if (flp.v) t += 'scaleY(-1) ';
    img.style.transform = t.trim() || 'none';
    const sideways = rot === 90 || rot === 270;
    img.style.maxWidth = sideways ? '68%' : '100%';
    img.style.maxHeight = sideways ? '68%' : 'none';
}

let dragSrcPage = null;

function initDragDrop() {
    const grid = document.getElementById('pagesGrid');
    if (grid.dataset.dndInit) return;
    grid.dataset.dndInit = '1';

    grid.addEventListener('dragstart', e => {
        const card = e.target.closest('.page-card');
        if (!card) return;
        dragSrcPage = parseInt(card.dataset.page);
        requestAnimationFrame(() => card.classList.add('dragging'));
        e.dataTransfer.effectAllowed = 'move';
    });

    grid.addEventListener('dragend', () => {
        grid.querySelectorAll('.page-card').forEach(c => c.classList.remove('dragging', 'drag-over'));
        dragSrcPage = null;
    });

    grid.addEventListener('dragover', e => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        const card = e.target.closest('.page-card');
        if (!card) return;
        const targetPage = parseInt(card.dataset.page);
        if (targetPage === dragSrcPage) return;
        grid.querySelectorAll('.page-card.drag-over').forEach(c => c.classList.remove('drag-over'));
        card.classList.add('drag-over');
    });

    grid.addEventListener('dragleave', e => {
        const card = e.target.closest('.page-card');
        if (card && !card.contains(e.relatedTarget)) {
            card.classList.remove('drag-over');
        }
    });

    grid.addEventListener('drop', e => {
        e.preventDefault();
        const targetCard = e.target.closest('.page-card');
        if (!targetCard || dragSrcPage === null) return;
        const targetPage = parseInt(targetCard.dataset.page);
        if (targetPage === dragSrcPage) return;

        const si = pageOrder.indexOf(dragSrcPage);
        const ti = pageOrder.indexOf(targetPage);
        pageOrder.splice(si, 1);
        pageOrder.splice(ti, 0, dragSrcPage);

        const srcCard = grid.querySelector(`.page-card[data-page="${dragSrcPage}"]`);
        if (srcCard) {
            if (si < ti) targetCard.after(srcCard);
            else targetCard.before(srcCard);
        }
    });
}

function setCategory(pageNum, value) {
    if (!value) delete pageCategories[pageNum];
    else pageCategories[pageNum] = value;
    const card = document.querySelector(`.page-card[data-page="${pageNum}"]`);
    if (card) card.classList.toggle('categorized', !!value);
    updateProgress();
}

function applyBulkCategory() {
    const val = bulkSelect.value;
    if (!val) { showToast('Choose a category first.', 'warn'); return; }
    let applied = 0;
    for (let i = 1; i <= totalPages; i++) {
        if (!pageCategories[i]) {
            pageCategories[i] = val;
            const card = document.querySelector(`.page-card[data-page="${i}"]`);
            if (card) { card.querySelector('select').value = val; card.classList.add('categorized'); }
            applied++;
        }
    }
    if (applied === 0) showToast('All pages already categorized.', 'warn');
    else showToast(`Applied to ${applied} page${applied!==1?'s':''}.`, 'success');
    updateProgress();
}

function clearAllCategories() {
    for (let i = 1; i <= totalPages; i++) {
        delete pageCategories[i];
        const card = document.querySelector(`.page-card[data-page="${i}"]`);
        if (card) { card.querySelector('select').value = ''; card.classList.remove('categorized'); }
    }
    showToast('All categories cleared.', 'warn');
    updateProgress();
}

function updateProgress() {
    const assigned = Object.keys(pageCategories).length;
    const pct = totalPages ? Math.round((assigned / totalPages) * 100) : 0;
    const unassigned = totalPages - assigned;
    const numCats = new Set(Object.values(pageCategories)).size;

    document.getElementById('progressFill').style.width = pct + '%';
    document.getElementById('progressLabelText').textContent = `${assigned} of ${totalPages} page${totalPages!==1?'s':''} assigned`;
    document.getElementById('progressLabelPct').textContent = pct + '%';
    document.getElementById('downloadBtn').disabled = assigned === 0;
    document.getElementById('actionBarInfo').textContent = assigned > 0
        ? `${assigned} page${assigned!==1?'s':''} ¬∑ ${numCats} categor${numCats!==1?'ies':'y'} ¬∑ ready to export`
        : 'Assign categories to pages, then download.';

    const banner = document.getElementById('uncategorizedBanner');
    if (assigned > 0 && unassigned > 0) {
        document.getElementById('uncategorizedText').textContent = `${unassigned} page${unassigned!==1?'s':''} without a category will be skipped.`;
        banner.classList.add('visible');
    } else {
        banner.classList.remove('visible');
    }
}

// ‚îÄ‚îÄ Annotation state ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const pageAnnotationHistory = {}; // pageNum -> [dataURL, ...]

function initAnnotToolbar(pageNum, card) {
    const tb = card.querySelector(`#annot-toolbar-${pageNum}`);
    if (!tb) return;

    // Tool selection
    tb.querySelectorAll('.annot-tool').forEach(btn => {
        btn.addEventListener('click', e => {
            e.stopPropagation();
            tb.querySelectorAll('.annot-tool').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            const isText = btn.dataset.tool === 'text';
            tb.querySelector('.annot-fontsize').style.display = isText ? '' : 'none';
        });
    });

    // Hide fontsize by default (pen is default tool)
    tb.querySelector('.annot-fontsize').style.display = 'none';

    // Undo / clear actions
    tb.querySelector('[data-action="undo"]').addEventListener('click', e => {
        e.stopPropagation();
        undoAnnotation(pageNum);
    });
    tb.querySelector('[data-action="clear"]').addEventListener('click', e => {
        e.stopPropagation();
        clearAnnotations(pageNum);
    });

    // Prevent toolbar interactions from triggering card drag
    tb.addEventListener('mousedown', e => e.stopPropagation());
}

function initAnnotCanvas(pageNum, canvas, img) {
    const w = img.naturalWidth || 400;
    const h = img.naturalHeight || 300;
    if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w;
        canvas.height = h;
    }
    if (!pageAnnotationHistory[pageNum]) pageAnnotationHistory[pageNum] = [];

    // Restore existing annotation if history present
    const hist = pageAnnotationHistory[pageNum];
    if (hist.length > 0) {
        const restored = new Image();
        restored.src = hist[hist.length - 1];
        restored.onload = () => canvas.getContext('2d').drawImage(restored, 0, 0);
        restored.onerror = () => console.warn(`Could not restore annotation for page ${pageNum}`);
    }

    setupAnnotationDrawing(pageNum, canvas);
}

function getActiveTool(pageNum) {
    const tb = document.getElementById(`annot-toolbar-${pageNum}`);
    if (!tb) return 'pen';
    const active = tb.querySelector('.annot-tool.active');
    return active ? active.dataset.tool : 'pen';
}

function getAnnotColor(pageNum) {
    const tb = document.getElementById(`annot-toolbar-${pageNum}`);
    return tb ? tb.querySelector('.annot-color').value : '#ff0000';
}

function getAnnotBrushSize(pageNum) {
    const tb = document.getElementById(`annot-toolbar-${pageNum}`);
    return tb ? parseInt(tb.querySelector('.annot-brush').value) || 3 : 3;
}

function getAnnotFontSize(pageNum) {
    const tb = document.getElementById(`annot-toolbar-${pageNum}`);
    return tb ? parseInt(tb.querySelector('.annot-fontsize').value) || 16 : 16;
}

function setupAnnotationDrawing(pageNum, canvas) {
    const ctx = canvas.getContext('2d');
    let drawing = false;
    let startX, startY;
    let snapshotData = null;

    function getCoords(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const src = e.touches ? e.touches[0] : e;
        return {
            x: (src.clientX - rect.left) * scaleX,
            y: (src.clientY - rect.top) * scaleY
        };
    }

    function startDraw(e) {
        e.preventDefault();
        e.stopPropagation();
        const tool = getActiveTool(pageNum);
        const { x, y } = getCoords(e);

        if (tool === 'text') {
            handleTextInput(pageNum, canvas, x, y);
            return;
        }

        drawing = true;
        startX = x; startY = y;

        if (tool !== 'pen') {
            snapshotData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        } else {
            ctx.beginPath();
            ctx.moveTo(x, y);
        }

        // Disable card drag while drawing
        const card = canvas.closest('.page-card');
        if (card) card.draggable = false;
    }

    function moveDraw(e) {
        if (!drawing) return;
        e.preventDefault();
        e.stopPropagation();
        const { x, y } = getCoords(e);
        const tool = getActiveTool(pageNum);
        const color = getAnnotColor(pageNum);
        const size = getAnnotBrushSize(pageNum);

        ctx.strokeStyle = color;
        ctx.lineWidth = size;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        if (tool === 'pen') {
            ctx.lineTo(x, y);
            ctx.stroke();
        } else if (snapshotData) {
            ctx.putImageData(snapshotData, 0, 0);
            if (tool === 'line')   drawLine(ctx, startX, startY, x, y, color, size);
            else if (tool === 'rect')   drawRect(ctx, startX, startY, x, y, color, size);
            else if (tool === 'circle') drawCircle(ctx, startX, startY, x, y, color, size);
            else if (tool === 'arrow')  drawArrow(ctx, startX, startY, x, y, color, size);
        }
    }

    function endDraw(e) {
        if (!drawing) return;
        e.preventDefault();
        drawing = false;
        const tool = getActiveTool(pageNum);
        if (tool === 'pen') ctx.closePath();
        snapshotData = null;
        saveAnnotState(pageNum, canvas);
        const card = canvas.closest('.page-card');
        if (card) card.draggable = true;
    }

    canvas.addEventListener('mousedown', startDraw);
    canvas.addEventListener('mousemove', moveDraw);
    canvas.addEventListener('mouseup', endDraw);
    canvas.addEventListener('mouseleave', endDraw);
    canvas.addEventListener('touchstart', startDraw, { passive: false });
    canvas.addEventListener('touchmove', moveDraw, { passive: false });
    canvas.addEventListener('touchend', endDraw);
}

function drawLine(ctx, x1, y1, x2, y2, color, size) {
    ctx.beginPath();
    ctx.strokeStyle = color; ctx.lineWidth = size; ctx.lineCap = 'round';
    ctx.moveTo(x1, y1); ctx.lineTo(x2, y2);
    ctx.stroke();
}

function drawRect(ctx, x1, y1, x2, y2, color, size) {
    ctx.beginPath();
    ctx.strokeStyle = color; ctx.lineWidth = size;
    ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
}

function drawCircle(ctx, x1, y1, x2, y2, color, size) {
    const cx = (x1 + x2) / 2, cy = (y1 + y2) / 2;
    const rx = Math.abs(x2 - x1) / 2, ry = Math.abs(y2 - y1) / 2;
    ctx.beginPath();
    ctx.strokeStyle = color; ctx.lineWidth = size;
    ctx.ellipse(cx, cy, rx, ry, 0, 0, 2 * Math.PI);
    ctx.stroke();
}

function drawArrow(ctx, x1, y1, x2, y2, color, size) {
    const angle = Math.atan2(y2 - y1, x2 - x1);
    // headLen: min 14px for visibility, scaled with stroke width (4√ó) for proportional arrows
    const headLen = Math.max(14, size * 4);
    ctx.strokeStyle = color; ctx.fillStyle = color; ctx.lineWidth = size; ctx.lineCap = 'round';
    ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x2, y2);
    ctx.lineTo(x2 - headLen * Math.cos(angle - Math.PI / 6), y2 - headLen * Math.sin(angle - Math.PI / 6));
    ctx.lineTo(x2 - headLen * Math.cos(angle + Math.PI / 6), y2 - headLen * Math.sin(angle + Math.PI / 6));
    ctx.closePath(); ctx.fill();
}

function handleTextInput(pageNum, canvas, x, y) {
    const container = canvas.parentElement;
    const rect = canvas.getBoundingClientRect();
    const scaleX = rect.width / canvas.width;
    const scaleY = rect.height / canvas.height;
    const fontSize = getAnnotFontSize(pageNum);
    const color = getAnnotColor(pageNum);

    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'annot-text-input';
    input.style.cssText = `left:${x * scaleX}px;top:${(y - fontSize) * scaleY}px;` +
        `font-size:${fontSize * scaleY}px;color:${color};border-color:${color};`;
    container.appendChild(input);
    input.focus();

    let committed = false;
    function commit() {
        if (committed) return;
        committed = true;
        if (input.value.trim()) {
            const ctx = canvas.getContext('2d');
            ctx.font = `${fontSize}px DM Sans, sans-serif`;
            ctx.fillStyle = color;
            ctx.fillText(input.value, x, y);
            saveAnnotState(pageNum, canvas);
        }
        if (input.parentNode) input.parentNode.removeChild(input);
    }
    input.addEventListener('keydown', e => {
        if (e.key === 'Enter') { e.preventDefault(); commit(); }
        if (e.key === 'Escape') { committed = true; if (input.parentNode) input.parentNode.removeChild(input); }
    });
    input.addEventListener('blur', commit);
}

function saveAnnotState(pageNum, canvas) {
    if (!pageAnnotationHistory[pageNum]) pageAnnotationHistory[pageNum] = [];
    pageAnnotationHistory[pageNum].push(canvas.toDataURL('image/png'));
}

function undoAnnotation(pageNum) {
    const hist = pageAnnotationHistory[pageNum];
    if (!hist || hist.length === 0) { showToast('Nothing to undo.', 'warn'); return; }
    hist.pop();
    const canvas = document.getElementById(`annot-canvas-${pageNum}`);
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (hist.length > 0) {
        const img = new Image();
        img.src = hist[hist.length - 1];
        img.onload = () => ctx.drawImage(img, 0, 0);
        img.onerror = () => showToast('Could not restore previous annotation state.', 'warn');
    }
}

function clearAnnotations(pageNum) {
    const canvas = document.getElementById(`annot-canvas-${pageNum}`);
    if (!canvas) return;
    canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
    pageAnnotationHistory[pageNum] = [];
}
// ‚îÄ‚îÄ End annotation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

async function downloadSeparatedPDFs() {
    const categorizedPages = {};
    for (const origPage of pageOrder) {
        const cat = pageCategories[origPage];
        if (cat) {
            if (!categorizedPages[cat]) categorizedPages[cat] = [];
            categorizedPages[cat].push(origPage);
        }
    }

    if (Object.keys(categorizedPages).length === 0) {
        showToast('Please assign at least one category first.', 'error');
        return;
    }

    showLoading('Building PDFs‚Ä¶', 'Please wait');

    try {
        const arrayBuffer = await originalFileBlob.arrayBuffer();
        const { PDFDocument, degrees } = PDFLib;
        const srcPdf = await PDFDocument.load(arrayBuffer);
        const zip = new JSZip();

        for (const [category, pages] of Object.entries(categorizedPages)) {
            const newPdf = await PDFDocument.create();
            for (const pageNum of pages) {
                const [pg] = await newPdf.copyPages(srcPdf, [pageNum - 1]);
                const rot = pageRotations[pageNum] || 0;
                if (rot !== 0) {
                    const existingRot = pg.getRotation ? pg.getRotation().angle : 0;
                    pg.setRotation(degrees((existingRot + rot) % 360));
                }
                newPdf.addPage(pg);

                // Embed annotations if any
                const annotCanvas = document.getElementById(`annot-canvas-${pageNum}`);
                const annotHist = pageAnnotationHistory[pageNum];
                if (annotCanvas && annotHist && annotHist.length > 0) {
                    try {
                        const dataUrl = annotCanvas.toDataURL('image/png');
                        const base64 = dataUrl.split(',')[1];
                        const annotBytes = Uint8Array.from(atob(base64), c => c.charCodeAt(0));
                        const annotImg = await newPdf.embedPng(annotBytes);
                        const addedPage = newPdf.getPages()[newPdf.getPageCount() - 1];
                        const { width, height } = addedPage.getSize();
                        addedPage.drawImage(annotImg, { x: 0, y: 0, width, height });
                    } catch (annotErr) {
                        console.warn(`Annotation embed failed for page ${pageNum}:`, annotErr);
                    }
                }
            }
            const pdfBytes = await newPdf.save();
            const label = CATEGORIES.find(c => c.value === category)?.label || category;
            zip.file(`${label.replace(/\s+/g, '_')}.pdf`, pdfBytes);
        }

        document.getElementById('loaderText').textContent = 'Generating ZIP‚Ä¶';
        const zipBlob = await zip.generateAsync({ type: 'blob' });

        const url = URL.createObjectURL(zipBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'Categorized_Documents.zip';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        setTimeout(() => URL.revokeObjectURL(url), 300);

        hideLoading();
        const count = Object.keys(categorizedPages).length;
        showToast(`Downloaded ${count} PDF${count!==1?'s':''} in a ZIP.`, 'success');
    } catch (err) {
        hideLoading();
        showToast(`Download failed: ${err.message}`, 'error');
    }
}

function resetApp() {
    originalFileBlob = null;
    pdfDoc = null;
    totalPages = 0;
    pageOrder = [];
    Object.keys(pageCategories).forEach(k => delete pageCategories[k]);
    Object.keys(pageRotations).forEach(k => delete pageRotations[k]);
    Object.keys(pageFlips).forEach(k => delete pageFlips[k]);
    Object.keys(thumbnailCache).forEach(k => delete thumbnailCache[k]);
    Object.keys(pageAnnotationHistory).forEach(k => delete pageAnnotationHistory[k]);
    document.getElementById('pagesSection').classList.remove('active');
    document.getElementById('uploadSection').style.display = '';
    document.getElementById('actionBar').style.display = 'none';
    const g = document.getElementById('pagesGrid');
    g.innerHTML = '';
    delete g.dataset.dndInit;
    document.getElementById('uncategorizedBanner').classList.remove('visible');
    fileInput.value = '';
    updateProgress();
}

function showLoading(text, sub) {
    document.getElementById('loaderText').textContent = text;
    document.getElementById('loaderSub').textContent = sub || '';
    document.getElementById('loadingOverlay').classList.add('active');
}

function hideLoading() {
    document.getElementById('loadingOverlay').classList.remove('active');
}

function showToast(message, type = 'success') {
    const icons = { success: '‚úì', error: '‚úï', warn: '!' };
    const t = document.createElement('div');
    t.className = `toast ${type}`;
    t.innerHTML = `<div class="toast-icon">${icons[type]||'‚Ä¢'}</div><span>${message}</span>`;
    document.getElementById('toastContainer').appendChild(t);
    setTimeout(() => { t.classList.add('hide'); setTimeout(() => t.remove(), 280); }, 4000);
}
</script>
</body>
</html>